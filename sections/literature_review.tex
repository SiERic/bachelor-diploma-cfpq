\section{Обзор литературы}\label{section:voda}

Задача поиска путей с контекстно-свободными ограничениями (она же CFPQ) была сформулирована Михалисом Яннакакисом ещё в 1990 году~\cite{Yannakakis1990} в применении к запросам к базам данных, написанных на декларативном языке Datalog~\cite{DatalogWiki, Ceri1989}.

В последнее десятилетие интерес к задаче возродился в контексте запросов к RDF\footnote{Resource Description Framework~--- Среда описания ресурса}~\cite{RDF}~--- графовой модели представления данных в сети, разработанной W3C\footnote{World Wide Web Consortium~--- Консорциум Всемирной паутины}. RDF хранит объекты (ресурсы) и утверждения об их связях (тройки <<субъект~--- предикат~--- объект>>). Чаще всего для работы с данными, представленными в RDF, используют язык запросов SPARQL~\cite{SPARQL}. Однако SPARQL позволяет осуществлять только запросы, представленные в виде регулярных выражений, тогда как некоторые интересные запросы (такие как \textit{same-generation queries}\footnote{Запросы поиска объектов, находящихся на одном уровне иерархии}~\cite{Abiteboul1995}) могут быть выражены только в терминах контекстно-свободных языков.

Задача также нашла широкое применение в разных видах статического анализа~\cite{Reps1998} (в этой области она более известная под именем задачи контекстно-свободной достижимости или CFL-Reachability), таких как межпроцедурный слайсинг (interprocedural slicing)~\cite{Reps1994},  анализ указателей (points-to analysis)~\cite{Sridharan06, Xu09}, анализ псевдонимов (alias analysis)~\cite{Zheng08, Yan11, Zhang13}, межпроцедурный анализ потока данных (interprocedural dataflow analysis)~\cite{Rehof01,Pratikakis06}, анализ формы (shape analysis)~\cite{Reps1998, Rinetzky07}, свёртка констант (constant propagation)~\cite{Sagiv1996} и другие~\cite{Pratikakis06, Milanova14, Bastani15}.

% In practice, widely-used large-scale analysis tools, such as Wala [Wal 2003]
% and Soot [Bodden 2012; Vallée-Rai et al. 1999], equip CFL reachability techniques to perform
% such analyses
% https://dl.acm.org/doi/pdf/10.1145/3158118

% https://www.cc.gatech.edu/~qrzhang/papers/oopsla2014_qirun.pdf
% reference

\subsection{Решения задачи в общем случае}

За более чем 30 лет было предложено множество алгоритмов для решения задачи CFPQ.
Большая часть решений реализует идеи различных алгоритмов разбора выражений (парсинга). Так, алгоритм Мельски и Репса~\cite{Reps97} использует тот же подход, что и алгоритм Кока-Янгера-Касами~\cite{Younger1967} парсинга КС-языков: приведение грамматики к нормальной форме Хомского~\cite{Chomsky1957} и использование метода динамического программирования~--- и имеет ту же асимптотику $\O(|V|^3 |N|^3)$, где $|V|$~--- число вершин в графе, $|N|$~--- число нетерминалов входной грамматики. Позднее Чаудхури~\cite{Chaudhuri06} улучшил этот алгоритм, уменьшив асимптотику в $\log |V|$ раз, используя метод четырёх русских~\cite{Arlazarov70}.

Алгоритм Григорьева и Рогозиной, основан на обобщённом нисходящем синтаксическом анализе\footnote{Top-down parsing}~--- GLL~\cite{Scott10} парсинге, и работает за $\O(|V|^3 \max\limits{v \in V} (deg^{+}(v)))$. Алгоритм Медейроса и др.~\cite{Medeiros18} также основан на нисходящем синтаксическом анализе~--- LL парсинге, но имеет время работы $\O(|V|^3 |P|)$, где $|P|$~--- число продукций входной грамматики.

Алгоритм Сантоса и др.~\cite{Santos18} основан на восходящем синтаксическом анализе\footnote{Bottom-up parsing}~--- Tomita-Style Generalized LR парсинге~\cite{Scott00}, однако его время работы не оценено, а на некоторых входах он вообще не завершается (однако на практике показывает хорошую производительность). 

Но есть и подходы, не основанные на алгоритмах парсинга. 
Например, в своей работе Азимов и Григорьев~\cite{Santos18} сводят задачу CFPQ к транзитивному замыканию матриц (по аналогии с решением Валианта~\cite{Valiant1975} задачи распознавания КС-языков). Преимущество этого алгоритма в том, что он использует операции над матрицами, которые могут быть соптимизированы с использованием GPGPU\footnote{General-purpose computing on graphics processing units~--- техника использования графического процессора для неграфических целей (математических вычислений)}.

Хеллингс в своей работе~\cite{Hellings15} рассматривает задачу в основанной на путях (path-based) семантике запроса и разрешает её, используя аннотированные грамматики.

Чаудхури~\cite{Chaudhuri08}, а также Орачев и др.~\cite{Orachev20} сводят задачу CFPQ к задаче достижимости в рекурсивном конечном автомате, которую решают, используя инкрементальное транзитивное замыкание. Наивная реализация работает за $\O(|V|^3 |N|^3)$, но так же (как и алгоритм Репса~\cite{Reps97,Chaudhuri06}) может быть соптимизирован~\cite{Shemetova21} в $\log |NV|$ раз методом четырёх русских.

\subsection{Нижние оценки}

Как можно заметить, все существующие алгоритмы (для решения CFPQ в общем случае) имеют кубическое (или большее) время работы. Что не достаточно эффективно для работы с реальными данными, как экспериментально показали Кёйперс и др.~\cite{Kuijpers19}, реализовав и замерив производительность трёх алгоритмов: Хеллингса~\cite{Hellings15}, Сантоса и др.~\cite{Santos18} и Азимова и др.~\cite{Santos18}.

Более того, скорее всего, решения с более быстрой ($\O(|V|^{3 - \eps})$) асимптотикой не существует. Это так называемый ``cubic bottleneck''\footnote{узкое место}~\cite{Heintze1997} данной задачи. Было доказано, что она является 2NPDA\footnote{2-way nondeterministic pushdown automata~\cite{Aho1968}~--- 2-сторонний автомат с магазинной памятью}-полной, и субкубическое решение для неё повлечёт наличие субкубических алгоритмов для всех задач класса. Учитывая, что такие решения не были найдены за более чем 50 лет, маловероятно, что данная задача решается быстрее куба. 

Существуют и другие условные нижние оценки. 

Так, Чаттерджи и др. в своей работе~\cite{Chatterjee17} построили условную нижнюю оценку, сведя к задаче CFPQ (а именно, к $\cool{D}_k$-достижимости (опр.~\ref{def:dyck_reach})) задачу BMM\footnote{Boolean Matrix Multiplication~--- перемножение двух булевых матриц}, на которую есть условная нижняя оценка. А именно, согласно BMM-гипотезе~\cite{Williams18}, не существует субкубического \textit{комбинаторного}\footnote{Этот термин не вполне определен, но можно понимать его как ``не алгебраический''. В частности, комбинаторные алгоритмы не должны использовать деление и вычитание, так как те пользуются особенностями алгебраических структур (а именно, существованием обратного)} алгоритма для перемножения двух булевых матриц. Замечание про комбинаторность алгоритма важно, так как алгебраическое субкубическое решения для BMM существует, а именно, она сводится к обычному перемножению матриц, которое может быть совершено за $\O(|V|^{\omega})$\footnote{$2 < \omega < 2.373$~\cite{Alman20}}.

Позднее Чжан~\cite{Zhang20} улучшил эту оценку, построив сведение BMM к $\cool{D}_1$-достижимости, тем показав, что, скорее всего, не существует субкубического комбинаторного решения уже для неё. 

И если с комбинаторными алгоритмами всё более менее понятно и оценки (нижняя и верхняя) сходятся, то с некомбинаторными всё не так радужно. Нижняя оценка в $\O(|V|^{\omega})$ вытекает из сведения от BMM, но обратного сведения не построено и непонятно, может ли эта оценка быть достигнута. Более того, существует условная нижняя оценка на нижнюю оценку: Чистиков и др.~\cite{Chistikov21} показали, что при условии NSETH\footnote{Nondeterministic Strong Exponential Time Hypothesis~--- Недетерминированная сильная гипотеза об экспоненциальном времени}~\cite{Carmosino16} не существует нижней оценки, основанной на SETH\footnote{Strong exponential time hypothesis~--- Сильная гипотеза об экспоненциальном времени}~\cite{Impagliazzo01} для $\cool{D}_2$-достижимости, лучшей, чем $\O(|V|^{\omega})$.

\subsection{Решения задачи в частных случаях}

Понятно, что для решения практических задач далеко не всегда нужна CFPQ в общем случае. Чаще всего для каждой конкретной задачи нужна конкретная КС грамматика, а иногда ещё и известны ограничения на тип графа.

Пользуясь этой информацией (ограничениями на тип грамматики и графа) можно конструировать частные, более быстрые решения, или давать более точные оценки на время работы существующих. 

Начнём с очевидных частных случаев. Так, для графа-цепочки задача CFPQ~--- это просто задача КС-распознавания, так как граф-цепочка~--- это просто одна строка. А для задачи КС-распознавания существует субкубическое решение~\cite{Valiant1975}, более того, она эквивалентна задаче перемножения булевых матриц (так что решается за $\O(|V|^{\omega})$). В своей работе~\cite{Yannakakis1990} Яннакакис также заметил, что это сведение можно обобщить на случай ацикличных графов.

Решение с такой же асимптотикой $\O(|V|^{\omega})$ получено для ещё одного частного случая~--- иерархических грамматик\footnote{Hierarchical state machines}~\cite{Yannakakis00}. На самом деле такие грамматики задают регулярные языки, однако размер автомата может быть экпоненциален относительно размера грамматики. Но если считать размер грамматики константным (как делают довольно часто), то задача поиска путей с регулярными ограничениями решается за $\O(V^{\omega})$, так как сводится~\cite{Yannakakis1990} к построению транзитивного замыкания входного графа (опр.~\ref{def:TC}).

Ещё одним из языков, для которых строятся частичные решения, является язык Дика.

% Язык Дика
\begin{definition}\label{def:dyck}
  \textit{Языком Дика}\footnote{Dyck language} на $k$ типах скобок $\cool{D}_k$ называют язык, заданный над алфавитом $\Sigma_k = \{ (_1, )_1, (_2, )_2 \dots (_k, )_k \}$ и состоящий из правильных скобочных последовательностей (или ПСП) на $k$ типах скобок.

  Язык Дика~--- контекстно-свободный и задаётся следующей грамматикой:\\ $\cool{D}_k : S \to S S~|~(_1 S )_1 ~|~ (_2 S )_2~|~ \dots (_k S )_k ~|~ \eps$

\end{definition}

\begin{definition}\label{def:dyck_reach}
  Задачу CFPQ для языка Дика называют также задачей Диковой достижимости\footnote{Dyck-reachability}~\cite{Kodumal04} или $\cool{D}_k$-достижимости.
\end{definition}

Задача Диковой достижимости широко применяется в статическом анализе, так как во многих видах анализа возникают парные объекты: вызовы и возвраты из функций~\cite{Tang15}, обращение по указателю и их разыменование~\cite{Zheng08}, запись и чтение из поля~\cite{Yan11}, взятие и возврат блокировки~\cite{Kahlon09}.

% A Dyck language essentially
% generates well-balanced parentheses, which can be used to
% capture well-paired program properties, such as function calls/returns [15, 16, 22], pointer references/dereferences [27,
% 28], locks/unlocks [10, 13], and field reads/writes [9, 24, 25].

% https://helloqirun.github.io/papers/pldi20_yuanbo2.pdf

Первыми улучшениями для задачи Диковой достижимости стали лучшие оценки на время работы уже существующих алгоритмов. Так, Кодумал и Айкен~\cite{Kodumal04} показали, что алгоритм Репса~\cite{Reps97}, применённый для грамматики Дика (размер которой $\O(k)$ для языка $\cool{D}_k$), имеет асимптотику $\O(|V|^3 k)$, тогда как обычная оценка ~--- $\O(|V|^3 k^3$). А Рехоф и Фендрих~\cite{Rehof01} показали оценку (также для алгоритма Репса) в $\O(|V|^3)$ для языка Дика и графов потока исполнения, построенных для решения задачи основанного на типах анализа потока\footnote{Type-based flow analysis}.

Как уже было сказано выше, существует кубическая нижняя оценка на время работы \textit{комбинаторного} алгоритма уже для задачи Диковой достижимости. Это однако не мешает существованию субкубических алгебраических алгоритмов. Так, для задачи достижимости для языка Дика \textit{на одном типе скобок} $\cool{D}_1$ были построены более быстрые алгоритмы. Бредфорд сводит~\cite{Bradford17} задачу $\cool{D}_1$-достижимости к $\O(\log^2 |V|)$ перемножениям AGMY-матриц\footnote{Alon, Galil, Margalit~\cite{Alon1997}; и Yuval~\cite{Yuval1976}}, каждое из которых может быть произведено за $\O(|V|^{\omega} \log |V|)$. Матиасен и др.~\cite{Mathiasen21} строят ``более комбинаторное'' решение, строя сведение $\cool{D}_1$-достижимости к $\O(\log^2)$ непосредственно перемножений булевых матриц (для подсчёта транзитивного замыкания графа~\cite{Aho1974}).

В общем же случае (для языка Дика более, чем на одном типе скобок) субкубических решений не существует. Однако они появляются при добавлении ограничений на вид графа. А именно, при рассмотрении двунаправленных графов. 

\begin{definition}
  Помеченный граф $G = \q{V, E, \Sigma_k}$ называют \textit{двунаправленным}\footnote{Bidirected graph}~\cite{Yuan09}, если в нём для каждого ребра $\q{u, v, (_i}$ найдётся противоположное ребро $\q{v, u, )_i}$ и наоборот.

  Неформально, матрица смежности такого графа симметрична, и метки на симметричных рёбрах~--- это парные открывающая/закрывающая скобки.
\end{definition}

\begin{figure}[h]
  \begin{minipage}[h]{0.5\linewidth}  
    \begin{tikzpicture}
      \tikzset{mynode/.append style={draw=black, circle,node distance=2cm}}
          
      \node[mynode] (n1)                {1};
      \node[mynode] (n2)  [right=of n1] {2};
      \node[mynode] (n3)  [above=of n2] {3};
      \node[mynode] (n4)  [right=of n3] {4};
      \node[mynode] (n5)  [above=of n4] {5};
      \node[mynode] (n6)  [right=of n2] {6};
          
      \draw[draw=black,->,semithick] (n1) edge node [midway,below] {\texttt{(}$_1$} (n2);
      \draw[draw=black,->,semithick,] (n1.100) to[out=100,in=170] node[above=of n1,above=0.1cm] {\texttt{(}$_2$} (n3);
      \draw[draw=black,->,semithick] (n2) edge node [midway,right] {\texttt{)}$_3$} (n3);
      \draw[draw=black,->,semithick] (n3) edge node [midway,below] {\texttt{(}$_2$} (n4);
      \draw[draw=black,->,semithick] (n2) edge node [midway,below] {\texttt{)}$_1$} (n6);
      \draw[draw=black,->,semithick] (n4) edge node [midway,right] {\texttt{)}$_2$} (n5);
      \draw[draw=black,<-,semithick,] (n3.100) to[out=100,in=170] node[above=of n1,above=0.1cm] {\texttt{(}$_1$} (n5);
    \end{tikzpicture}
    \caption{Обычный ориентированный граф}
    \label{img:path_0_2}
  \end{minipage}
  \hfill
  \begin{minipage}[h]{0.5\linewidth}  
    \begin{tikzpicture}
      \tikzset{mynode/.append style={draw=black, circle,node distance=2cm}}
          
      \node[mynode] (n1)                {1};
      \node[mynode] (n2)  [right=of n1] {2};
      \node[mynode] (n3)  [above=of n2] {3};
      \node[mynode] (n4)  [right=of n3] {4};
      \node[mynode] (n5)  [above=of n4] {5};
      \node[mynode] (n6)  [right=of n2] {6};
          
      \draw[draw=black,->,semithick,bend right=10] (n1) edge node [midway,below] {\texttt{(}$_1$} (n2);
      \draw[draw=black,<-,semithick,bend left=10]  (n1) edge node [midway,above] {\texttt{)}$_1$} (n2);
          
      \draw[draw=black,->,semithick,] (n1.100) to[out=100,in=170] node[above=of n1,above=0.1cm] {\texttt{(}$_2$} (n3);
      \draw[draw=black,<-,semithick,] (n1.80) to[out=80,in=190] node[above=of n1,right=0.1cm] {\texttt{)}$_2$} (n3);
          
      \draw[draw=black,->,semithick,bend right=10] (n2) edge node [midway,right] {\texttt{(}$_3$} (n3);
      \draw[draw=black,<-,semithick,bend left=10]  (n2) edge node [midway,left]  {\texttt{)}$_3$} (n3);
          
      \draw[draw=black,->,semithick,bend right=10] (n3) edge node [midway,below] {\texttt{(}$_2$} (n4);
      \draw[draw=black,<-,semithick,bend left=10]  (n3) edge node [midway,above] {\texttt{)}$_2$} (n4);
          
      \draw[draw=black,->,semithick,bend right=10] (n2) edge node [midway,below] {\texttt{(}$_1$} (n6);
      \draw[draw=black,<-,semithick,bend left=10]  (n2) edge node [midway,above] {\texttt{)}$_1$} (n6);
          
      \draw[draw=black,->,semithick,bend right=10] (n4) edge node [midway,right] {\texttt{(}$_2$} (n5);
      \draw[draw=black,<-,semithick,bend left=10]  (n4) edge node [midway,left]  {\texttt{)}$_2$} (n5);
          
      \draw[draw=black,->,semithick,] (n3.100) to[out=100,in=170] node[above=of n1,above=0.1cm] {\texttt{(}$_1$} (n5);
      \draw[draw=black,<-,semithick,] (n3.80) to[out=80,in=190] node[above=of n1,right=0.1cm] {\texttt{)}$_1$} (n5);    
    \end{tikzpicture}
    \caption{Двунаправленный граф}
    \label{img:path_3_1}
  \end{minipage}
\end{figure}

В своей работе Юань и др.~\cite{Yuan09} заметили, что при решении задачи анализа указателей\footnote{Points-to analysis} граф получается двунаправленным (так как отношения \t{GetField} и \t{PutField} взаимообратные). Также, они конструируют алгоритм, с временем работы $\O(|V| \log |V| \log k)$, в случае, если полученный граф является деревом. На внешнем уровне алгоритма строится центроидная декомпозиция, а для каждого конкретного центроида~--- бор $S$-префиксов\footnote{Строк, сформированных наивным алгоритмом проверки правильности скобочной последовательности с использованием стека} его поддерева. Чжан и др.~\cite{Zhang13}, заметив, что в двунаправленных графах Диково достижимые вершины формируют классы эквивалентности (\ref{lemma:bidir_equiv}), улучшили этот алгоритм, получив линейное время работы, а также сконструировали алгоритм для произвольных графов с временем работы $\O(|E| \log |E|)$. Позднее, Чаттерджи и др.~\cite{Chatterjee17} улучшили этот результат до $\O(|E| + |V| \alpha(|V|))$\footnote{$\alpha(n)$~--- обратная функция Аккермана}.

Если к задаче анализа указателей добавить контекстную чувствительность\footnote{Context sensitivity}, то есть кроме записи/чтения полей учитывать ещё и вызов/возврат из функций, то её можно сформулировать в терминах смешанной Диковой достижимости.

\pagebreak

% Оператор смешения
\begin{definition}
  Для двух языков $L_1$ и $L_2$, заданных над алфавитами $\Sigma_1$ и $\Sigma_2$ соответственно, определим \textit{оператор смешения}\footnote{Interleaving operator}~\cite{Li21} $\odot: L_1 \times L_2 \to (\Sigma_1 \cup \Sigma_2)^{*}$ следующим образом:
  \vspace{-\topsep}
  \begin{itemize}
    \setlength\itemsep{-0.1em}
    \item $a \odot \eps = \{ a \}$, где $a \in L_1$
    \item $\eps \odot b = \{ b \}$, где $b \in L_2$
    \item $c_1 a \odot c_2 b = \{ c_1 w~|~w \in (a \odot c_2 b) \} \cup \{ c_2 w~|~w \in (c_1 a \odot b) \}$,\\ где $a \in L_1, b \in L_2, c_1 \in \Sigma_1, c_2 \in \Sigma_2$
  \end{itemize}

  Можно также переопределить оператор смешения для двух языков:\\ $L_1 \odot L_2 = \bigcup\limits_{a \in L_1, b \in L_2} a \odot b$.
\end{definition}

%Смешанный язык Дика
\begin{definition}
  Пусть есть два языка Дика $\cool{D}_i$ и $\cool{D}_j$, заданные над разными алфавитами. Тогда назовём язык $\cool{D}_i \odot \cool{D}_j$ \textit{смешанным языком Дика}\footnote{Interleaved Dyck language или \s{InterDyck} language}.

  Неформально, это множество таких скобочных последовательностей, что их проекции на алфавиты $\Sigma_i$ и $\Sigma_j$ принадлежат $\cool{D}_i$ и $\cool{D}_j$ соответственно.

  Например, пусть $\cool{D}_b$~--- языка квадратных ПСП и $\cool{D}_p$~--- языка круглых ПСП. Тогда смешанный язык $\cool{D}_b \odot \cool{D}_p$ содержит такие слова как ``\texttt{([)]}'' и ``\texttt{([()(])[])}''.
\end{definition}

Однако, задача смешанной Диковой достижимости в общем случаем неразрешима~\cite{Reps00}. Более того, она неразрешима уже для языка $\cool{D}_2 \odot \cool{D}_2$ даже на двунаправленных графах. Поэтому Ли и др.~\cite{Li21} рассмотрели задачу $\cool{D}_1 \odot \cool{D}_1$-достижимости (на двунаправленных графах) и построили для неё алгоритм с временем работы $\O(|V|^7)$. Решение этой задачи можно использовать как приближение для более общей $\cool{D}_k \odot \cool{D}_k$-достижимости.

\subsection{Выводы и результаты по главе}

Задача поиска путей с контекстно-свободными ограничениями была сформулирована более 30 лет назад и применяется в работе с графовыми базами данных и в статическом анализе. Существует множество алгоритмов, для решения этой задачи, в большинстве своём, основанных на алгоритмах парсинга. Однако существующие алгоритмы недостаточно эффективны, более того, существует условная нижняя оценка в $\O(n^3)$, которая достигается большинством этих решений.

Для некоторых частных случаев уже были предложены более быстрые (субкубические) решения, все они были описаны в этой главе. Большая часть частных случаев так или иначе связана с языком Дика, так как в задачах статического анализа языком ограничений часто является именно он.

% \includegraphics[width=0.75\linewidth]{img/conclusion}
