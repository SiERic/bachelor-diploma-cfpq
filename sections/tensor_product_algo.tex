\section{Алгоритм, основанный на пересечении языков}\label{section:algo_idea}

В качестве единого подхода к построению частичных решений для задачи CFPQ был выбран алгоритм~\cite{Chaudhuri08, Orachev20}, основанный на пересечении языков. Причина выбора именно этого решения следующая: в основе остальных подходов лежат алгоритмы парсинга, все из которых имеют кубическое время работы и неизвестно, могут ли быть ускорены, тогда как данный подход основан на графовых алгоритмах (а именно, на решении задачи построения инкрементального транзитивного замыкания), за счёт чего более подвержен модификациям.

\subsection{Сведение к задаче достижимости для РКА}

Главной идеей алгоритма является следующее замечание: любой помеченный граф $G$ можно рассматривать как \textit{недетерминированный конечный автомат}, в котором не выбраны начальное и конечные состояния.

% Конечный автомат
\begin{definition}

  \textit{Недетерминированный конечный автомат (или НКА)}\footnote{Nondeterministic finite automaton (или NFA)}~--- это пятёрка $\q{Q, \Sigma, \delta, q_0, F}$:
  \vspace{-\topsep}
  \begin{itemize}
    \setlength\itemsep{-0.1em}
    \item $Q$~--- конечное множество состояний
    \item $\Sigma$~--- конечный алфавит
    \item $\delta \colon Q \times \Sigma \to 2^Q$~--- функция перехода
    \item $q_0 \in Q$~--- начальное (стартовое) состояние
    \item $T \subseteq Q$~--- множество конечных (терминальных) состояний
  \end{itemize}

  \textit{Язык, распознаваемый НКА} $\cool{A}$~--- язык $L(\cool{A})$ слов, на которых автомат, следуя функции перехода, может дойти из стартового состояние в терминальное хотя бы одним способом.

  Недетерминированные конечные автоматы задают \textit{регулярные языки}.

\end{definition}

\begin{adjustbox}{valign=T,raise=\strutheight,minipage={\linewidth}}
  \begin{wrapfigure}{r}{0.47\linewidth}
      \begin{tikzpicture}[shorten >=1pt,auto]
        \node[state, initial]   (q_0)                      {$0$};
        \node[state]            (q_1) [above right=of q_0] {$1$};
        \node[state]            (q_2) [right=of q_0]       {$2$};
        \node[state]            (q_3) [right=of q_2]       {$3$};
        \node[state, accepting] (q_4) [right=of q_3]       {$4$};
        \path[->]
          (q_0) edge node {$b$} (q_1)
          (q_1) edge node {$b$} (q_2)
          (q_2) edge node {$b$} (q_0)
          (q_2) edge node {$a$} (q_3)
          (q_3) edge node {$b$} (q_4)
          (q_0) edge[loop below] node {$a$} (q_0)
          (q_1) edge[loop above] node {$a$} (q_1)
          (q_2) edge[loop below] node {$a$} (q_2);
      \end{tikzpicture}
      \caption{Пример НКА}
      \label{img:nfa}
    \end{wrapfigure}

  \strut{}
  \vspace*{-3em}
  \begin{example}
    Автомат на рисунке~\ref{img:nfa} задаёт язык слов, содержащих кратное трём число букв $b$ и заканчивающихся на $ab$.

    Опишем его подробнее. Алфавит состоит из двух символов $a$ и $b$: $\Sigma = \{a, b \}$, состояний 5 штук: $Q = \{0, 1, 2, 3, 4\}$, при этом $q_0 = 0$, а терминальное состояние всего одно: $T = \{4\}$. Функция перехода $\delta$ соответствует рёбрам автомата.
  \end{example}

\end{adjustbox}

\begin{wrapfigure}{l}{0.4\linewidth}
  \begin{tikzpicture}[shorten >=1pt,auto]
    \node[state, initial]   (q_0)                      {$0$};
    \node[state]            (q_1) [above right=of q_0] {$1$};
    \node[state, accepting] (q_2) [right=of q_0]       {$2$};
    \node[state]            (q_3) [right=of q_2]       {$3$};
    \path[->]
      (q_0) edge  node {$a$} (q_1)
      (q_1) edge  node {$a$} (q_2)
      (q_2) edge  node {$a$} (q_0)
      (q_2) edge[bend left, above] node {$b$} (q_3)
      (q_3) edge[bend left, below] node {$b$} (q_2);
  \end{tikzpicture}
  \caption{НКА, задающий слова, читаемые на путях $0 \path 2$.\\ Например, $aa$, $aabb$ или $aabbaaa$}
  \label{img:nfa_0_2}
\end{wrapfigure}

\begin{proposition}
  Если зафиксировать конкретные вершины $u$ и $v$ помеченного графа $G$ как стартовое и конечное состояния, то полученный автомат будет задавать язык слов, читаемых на путях из $u$ в $v$.

\end{proposition}

Язык, задаваемый подобным автоматом, будем обозначать как $L(G, u, v)$.

Получаем, что для каждой пары вершин $u$ и $v$, наличие пути $p \colon u \path v$, такого, что на нём читается слово $w \in L(\cool{G})$ равносильно непустоте пересечения языков $L(G, u, v)$ и $L(\cool{G})$ (действительно, в пересечении будут лежать ровно слова, выводимые грамматикой и при этом читаемые на каком-либо пути $u \path v$).

Для построения пересечения языков нам потребуется такая конструкция, как \textit{прямое произведение автоматов}.

% Прямое произведение автоматов
\begin{definition}

  Для двух НКА $\cool{A}_1 = \q{Q_1, \Sigma_1, \delta_1, q_{01}, T_1}$ и $\cool{A}_2 = \q{Q_2, \Sigma_2, \delta_2, q_{02}, T_2}$ \textit{прямым произведением} $\cool{A} = \cool{A}_1 \otimes \cool{A}_2$ назовём НКА $\cool{A} = \q{Q, \Sigma, \delta, q_0, T}$, такой что:
  \vspace{-\topsep}
  \begin{itemize}
    \setlength\itemsep{-0.1em}
    \item $Q = Q_1 \times Q_2$ (то есть состояние в $\cool{A}$~--- пара состояний в $\cool{A}_1$ и $\cool{A}_2$)
    \item $\Sigma = \Sigma_1 \cap \Sigma_2$
    \item для переходов $s_1 \xrightarrow{a} t_1 \in \delta_1$ и $s_2 \xrightarrow{a} t_2 \in \delta_2$ существует переход $\q{s_1, s_2} \xrightarrow{a} \q{t_1, t_2}$ 
    \item $q_0 = \q{q_{01}, q_{02}}$
    \item $T = T_1 \times T_2$
  \end{itemize}

\end{definition}

\begin{proposition}\label{prop:reg_inter} \cite{Hopcroft1979}
  Автомат $\cool{A}$, построенный как прямое произведение автоматов $\cool{A}_1$ и $\cool{A}_2$, распознаёт язык, равный пересечению языков $\cool{A}_1$ и $\cool{A}_2$.
\end{proposition}

Заметим, однако, что лишь один из языков, чьё пересечение нам нужно, является регулярным (и, следовательно, задаётся автоматом)~--- язык входного графа. Второй же язык является контекстно-свободным и недетерминированный конечным автоматом не задаётся. Однако он задаётся с помощью более сложного автомата~--- \textit{рекурсивного}. 

% Рекурсивный конечный автомат (РКА)
\begin{definition}
  \textit{Рекурсивный конечный автомат (или РКА)}\footnote{Recursive state machine (или RSM)}~\cite{Alur05}~--- это набор компонент $\q{M_1, M_2, \dots, M_k}$, с выделенной стартовой компонентой, где каждая компонента $M_i$~--- это пятёрка $\q{Q_i, \Sigma_i, En_i, Ex_i, \delta_i}$:
      \vspace{-\topsep}
      \begin{itemize}
        \setlength\itemsep{-0.1em}
        \item $Q_i$~--- конечное множество состояний
        \item $\Sigma_i$~--- конечный алфавит
        \item $En_i \subset Q_i$~--- множество начальных состояний
        \item $Ex_i \subset Q_i$~--- множество конечных состояний
        \item $\delta_i \colon Q_i \times (\Sigma_i \cup \bigcup\limits_{j = 1}^k En_i \times Ex_i ) \to 2^{Q_i}$~--- функция перехода. У $\delta_i$ есть два типа переходов: \textit{внутренние}, которые работают как обычные переходы в НКА и \textit{рекурсивные}, которые делают вызов другой компоненты (при этом обозначая начальную и конечную вершину в ней).
      \end{itemize}

  Неформально, это набор компонент, каждая из которых представляет собой НКА, на рёбрах которого могут быть ``рекурсивные вызовы'' других компонент.

  % Язык, задаваемый РКА $\cool{R}$~--- язык $L(\cool{R})$ слов, на которых автомат, следуя функции перехода, может дойти от начального до конечного состояния стартовой компоненты хотя бы одним способом.
\end{definition}

\begin{example}
  Вспомним грамматику для языка слов вида $b^n a^m b^{2n}$ (пример~\ref{example:bab}):

  \begin{align*}
    L \colon &S \to b S bb ~|~ A \\
    &A \to aA ~|~ \eps
  \end{align*}

  РКА по грамматике обычно строится следующим образом: создаётся компонента для каждого нетерминала, в которой проводятся пути, соответствующие продукциям.

\end{example}

\begin{figure}[h]
  \begin{minipage}[t]{0.6\linewidth}  
    \begin{tikzpicture}[shorten >=1pt,auto]
      \node[state, initial]   (q_0)                      {$0$};
      \node[state]            (q_1) [right=of q_0]       {$1$};
      \node[state]            (q_2) [right=of q_1]       {$2$};
      \node[state]            (q_3) [right=of q_2]       {$3$};
      \node[state, accepting] (q_4) [right=of q_3]       {$3$};
      \path[->]
        (q_0) edge  node {$b$} (q_1)
        (q_1) edge  node {$S$} (q_2)
        (q_2) edge  node {$b$} (q_3)
        (q_3) edge  node {$b$} (q_4)
        (q_0) edge[bend right, below] node {$A$} coordinate (e_1) (q_4);
    \end{tikzpicture}
    \subcaption{Компонента $S$}
    \label{img:bab_S}
  \end{minipage}
  \hfill
  \begin{minipage}[t]{0.4\linewidth}  
    \begin{tikzpicture}[shorten >=1pt, auto]
      \node[state, initial]   (q_0)                      {$0$};
      \node[state]            (q_1) [right=of q_0]       {$1$};
      \node[state, accepting] (q_2) [right=of q_1]       {$2$};
      \path[->]
        (q_0) edge  node {$a$} (q_1)
        (q_1) edge  node {$A$} (q_2)
        (q_0) edge[bend right, below] node {$\eps$} coordinate (e_1) (q_2);
    \end{tikzpicture}
    \subcaption{Компонента $A$}
    \label{img:bab_A}
  \end{minipage}
  \caption{РКА для языка $b^n a^m b^{2n}$}
\end{figure} 

\begin{proposition}\cite{Alur05}
  Утверждение \ref{prop:reg_inter} остаётся верным, если один из языков задан РКА. 
\end{proposition}

При прямом произведении НКА и РКА получается также РКА. А именно, при произведении РКА $\cool{R} = \q{M_1, \dots, M_k},  M_i = \q{Q_i, \Sigma_i, En_i, Ex_i, \delta_i}$ и НКА $\cool{A} = \q{Q, \Sigma, \delta, q_0, F}$, получается РКА $\cool{P} = \cool{R} \otimes \cool{A}$, состоящий из $k$ компонент $\cool{M}_i$, таких что
  \vspace{-\topsep}
  \begin{itemize}
    \setlength\itemsep{-0.1em}
    \item множество состояний $\cool{M}_i$ равно декартову произведению $Q_i \times Q$
    \item множество начальных состояний $\cool{M}_i$ равно $En_i \times Q$
    \item множество конечных  состояний $\cool{M}_i$ равно $Ex_i \times Q$
    \item для каждого внутреннего перехода $q_s \xrightarrow{a} q_t \in \delta_i$, в $\cool{M}_i$ есть внутренние переходы $\q{q_s, u} \xrightarrow{a} \q{q_t, v}$ для всех $u, v \in Q$, что $u \xrightarrow{a} v \in \delta$
    \item для каждого внешнего перехода $\q{q_s \xrightarrow{en, ex} q_t} \in \delta_i$, в $\cool{M}_i$ есть внешние переходы $\q{q_s, q} \xrightarrow{\q{en, q}, \q{ex, q}} \q{q_t, q}$ для всех $q \in Q$
  \end{itemize}

Для проверки непустоты получившегося языка, нужно проверить, существует ли путь из стартового состояния $\q{q_s, u}$ в конечное состояние $\q{q_t, v}$ ($q_s$ и $q_t$ принадлежат начальной компоненте). То есть решить задачу достижимости для РКА.

Как будет обсуждено позже, при решении задачи достижимости для РКА, строится матрица достижимости (то есть для каждой пары состояний находится, есть ли путь из одного в другое). Так что за один запуск такого алгоритма можно проверить контекстно-свободную достижимость для всех пар вершин исходного графа. 

Подводя итог, все алгоритмы для CFPQ, основанные на идее пересечения языков, будут иметь следующую схему:
\begin{enumerate}
    \item Построить прямое произведение входной грамматики $\cool{R}$ и входного графа $G$: $\cool{P} = \cool{R} \otimes G$.
    \item \textit{Решить задачу достижимости для полученного РКА $\cool{P}$}
    \item Из вершины $u$ в вершину $v$ входного графа существует путь, выводимой входной грамматикой $\cool{G}$ $\EQ$ в $\cool{P}$ есть путь $(q_0, u) \path (q_f, v)$ из стартового в конечное состояние начальной компоненты РКА $\cool{P}$
\end{enumerate}

Второй пункт~--- решение задачи достижимости для РКА~--- будет подробно рассмотрен далее.

\subsection{Решение задачи достижимости для РКА}

Решение задачи достижимости для НКА эквивалентно~\cite{Yannakakis1990} решению задачи достижимости для обычного ориентированного графа и заключается в построении \textit{транзитивного замыкания}.

% Транзитивное замыкание
\begin{definition}\label{def:TC}
  Пусть дан ориентированный граф $G$. Тогда \textit{транзитивным замыканием графа} $G$ называют такой граф $G^{+}$, что $V(G^{+}) = V(G)$, а ребро $u \to v$ содержится в $E(G^{+})$ тогда и только тогда, когда $v$ достижима из $u$ в графе $G$. 

  То есть это просто граф, рёбра которого (как бинарное отношение) являются транзитивным замыканием рёбер исходного графа $G$.
\end{definition}

В случае РКА задача достижимости не решается так просто, так как про часть рёбер (все рекурсивные рёбра) непонятно, присутствуют ли они в графе. А именно, рекурсивное ребро $u \xrightarrow{en, ex} v$ присутствует (может быть использовано для построения путей) только если состояние $ex$ достижимо из состояния $en$.

Для обработки таких ситуаций задачу решают итеративно: при обнаружении достижимости пары вершин проводят новые рёбра (рекурсивные рёбра с соответствующей меткой) и обновляют отношение достижимости (после этого могут появиться новые рёбра, которые снова проводят, и так далее). Такая задача уже сводится к решению задачи \textit{поддержания инкрементального транзитивного замыкания}.

% Инкрементальное транзитивное замыкание
\begin{definition}
  Пусть дан ориентированный граф $G$. Тогда задача \textit{поддержания инкрементального транзитивного замыкания графа} $G$ заключается в ответах на следующие запросы:
  \vspace{-\topsep}
  \begin{itemize}
    \setlength\itemsep{-0.1em}
    \item Провести новое ребро $u \to v$
    \item Проверить связность вершин $u$ и $v$
  \end{itemize}

  \vspace{-5pt}

  То есть задача заключается в добавлении рёбер (поэтому оно и инкрементальное) и поддержании транзитивного замыкания.
\end{definition}

В листинге~\ref{algo:PI} приведён псевдокод алгоритма решения задачи достижимости для РКА, основанный на поддержании инкрементального транзитивного замыкания.

\begin{note}
  Отдельно, до начала основного алгоритма, нужно обработать $\eps$-переходы. Эта часть алгоритма опущена (здесь и далее) для простоты изложения. 
\end{note}

\begin{algorithm}[h]
    \floatname{algorithm}{Листинг}
    \begin{algorithmic}[1]
    \caption{Алгоритм достижимости для РКА}
    \label{algo:PI}
    \Function{RSMReachability2}{$\cool{R}$}
        \State{$A \gets$ Empty adjacency matrix}
        \State{$Q \gets$ Empty Queue}
        \For{$i \in 1..k$}
            \For{$u \xrightarrow{c} v \in \delta_i$}
                \State{$Q.Push(\q{u, v, i})$}
            \EndFor
        \EndFor
        \While{$Q$ is not Empty}
            \State{$\q{u, v, i} \gets Q.Pop()$}
            \If{$u \in En_i \wedge v \in En_i$}
                \Comment{Нашли новый путь}
                \State{$A \gets A \cup getEdges(i, u, v)$}
                \State{$Q.PushAll(getEdges(i, u, v))$}
                \Comment{Добавляем новые рёбра}
            \EndIf
            \For{$x \in Q_i$}
                \If{$A_{x, u} \wedge \overline{A_{x, v}}$}
                    \For{$y \in Q_i$} 
                        \If{$A_{v, y} \wedge \overline{A_{x, y}}$}
                            \State{$A \gets A \cup \q{x, y}$}
                            \State{$Q.Push(\q{x, y, i})$}
                            \Comment{Обновляем транзитивное замыкание}
                        \EndIf
                    \EndFor
                \EndIf
            \EndFor
        \EndWhile
    \State \Return $A$
    \EndFunction
    \end{algorithmic}
\end{algorithm}

Работа происходит над матрицей смежности $\cool{R}$~--- изначально туда записываются все внутренние (нерекурсивные) рёбра. 

В алгоритме используется стандартная реализация инкрементального транзитивного замыкания~\cite{Ibaraki1983}. Для этого в ходе работы алгоритма поддерживается рабочая очередь $Q$ рёбер транзитивного замыкания, которые были найдены, но ещё не обработаны. 

\pagebreak

\begin{wrapfigure}{r}{0.43\linewidth}\label{img:TC}
  \begin{tikzpicture}[shorten >=1pt, auto] 
     \node[state] (q_0)                          {$x$}; 
     \node[state] (q_1) [above right=6em of q_0] {$u$}; 
     \node[state] (q_2) [right=of q_1]       {$v$}; 
     \node[state] (q_3) [below right=6em of q_2] {$y$}; 
      \path[->] 
      (q_0) edge [decorate, decoration={snake}]  node {} (q_1)
      (q_1) edge [ultra thick, align=center]     node {} (q_2)
      (q_2) edge [decorate, decoration={snake}]  node {} (q_3)
      (q_0) edge [dashed, below]                 node {новый путь} (q_3);        
  \end{tikzpicture}
  \caption{Нахождение нового пути}
\end{wrapfigure}

При обработке очередного ребра, ищутся новые пути, которые проходя через него. А именно, пусть было добавлено ребро $u \to v$. Тогда далее перебирается вершина $x$, такая что из неё была достижима вершина $u$ ($x \path u$), но не была достижима вершина $v$ ($x \not\path v$). Из такой вершины $x$ становятся достижимы все вершины $y$, которые были достижимы из $v$ ($v \path y$).

Если новое ребро транзитивного замыкания (= путь в графе) соединяет начальную и конечную вершину, в очередь добавляются также все соответствующие ему рекурсивные рёбра: для нового пути $(en \in En_i) \path (ex \in Ex_i)$ проводятся все рёбра, соответствующие рекурсивным вызовам $i$-ой компоненты с начальной вершиной $en$ и конечной вершиной $ex$.

\subsubsection*{Время работы}

Внешний цикл итерируется по всем рёбрам, так что работает за $\O(|E^{*}|)$ (где $E^{*}$~--- рёбра итогового транзитивного замыкания). Добавление новых рёбер рассмотрит каждое ребро не более одного раза, так что тоже работает за $O(|E^{*}|)$. Нужно только оценить работу по поддержанию транзитивного замыкания. 

Цикл на строке 12 перебирает все вершины, так что отработает суммарно за $\O(|E^{*}| |V|)$. Внутренний цикл (строка 14) тоже перебирает все вершины, но после его выполнения будет добавлено хотя бы одно новое ребро ($x \to v$), так что суммарное время работы этих циклов также можно оценить как $\O(|E^{*}| |V|)$.

Итого, суммарное время работы составляет $\O(|E^{*}||V|)$, что в плотных графах будет равно $\Theta(|V|^3)$. 

\begin{note}
  Время работы инкрементального транзитивного замыкания можно ускорить в $\O(\log |V|)$ раз~\cite{Shemetova21}, воспользовавшись методом четырёх русских~\cite{Arlazarov70} (так как работа происходит над булевыми векторами).
\end{note}

\subsection{Получение решений для частных случаев}

Основой для получения частных решений будут модификации алгоритма~\ref{algo:PI}.

Как уже было сказано, узким местом алгоритма является поддержание инкрементального транзитивного замыкания. На его время работы (так же, как и на время работы задачи CFPQ) существует кубическая условная нижняя оценка: к ней сводится~\cite{Henzinger15} задача \s{OMv}\footnote{Online Matrix-Vector Multiplication~--- онлайн умножения матрицы и векторов}. 

Следовательно, чтобы получить более быстрые алгоритмы, нужно рассматривать такие частные случаи, для которых задачу инкрементального транзитивного замыкания можно решать за субкубическое время.

Опишем такие случаи:

\begin{itemize}
  \item \textit{Графы с ограниченной степенью}

    В~\cite{Yellin1993} представлен алгоритм для инкрементального транзитивного замыкания на графах с ограниченной исходящей степенью. Асимптотика алгоритма: $\O(d |E^{*}|)$, где $d$~--- ограничение сверху на исходящую степень графа.

  \item \textit{Планарные графы}

    Существует несколько алгоритмов (например~\cite{Karczmarz18}) для работы с динамически меняющимися планарными графами. Однако очень трудно гарантировать планарность РКА-произведения (тем более, при вставке рёбер), хотя бы потому, например, что планарные графы имеют линейное относительно числа вершин число рёбер.
  
  \item \textit{Автоматы с ограниченным стеком\footnote{Bounded-stack State Machines}~\cite{Chaudhuri08}}

    Для автоматов, РКА которых не уходит в рекурсию, был построен~\cite{Chaudhuri08} алгоритм, с временем работы $\O(|V|^3 / \log^2 |V|)$.

  \item \textit{Неориентированные графы}

    Подробнее рассмотрены в разделе~\ref{subsection:undirected}

  \item \textit{Графы с малым числом итераций добавления рёбер}
    
    Подробно рассмотрены в разделе~\ref{subsection:nitc}

\end{itemize}

\subsection{Выводы и результаты по главе}

В этой главе введены основные определения и идея пересечения языков. Также в ней описан алгоритм~\ref{algo:PI}, основанный на данной идее и реализующий поддержку инкрементального транзитивного замыкания. Решения для частных случаев, представленные в следующих двух главах, являются модификациями этого алгоритма.